#ifndef __TCHECKER_ALGORITHMS_PW_EMPTINESS_HH__
#define __TCHECKER_ALGORITHMS_PW_EMPTINESS_HH__

#include <list>
#include <ostream>
#include <utility>

#include "algorithms/emptiness.hh"
#include "base/global.hh"
#include "base/memory.hh"
#include "graph/graphoutput.hh"
#include "graph/nodescmp.hh"
#include "graph/pw.hh"

/*!
  \file pwemptiness.hh
  \brief Emptiness algorithms that use a passed-waiting list
*/

namespace algorithms {

  /*!
    \namespace pwemptiness
    \brief Emptiness algorithms that use a passed-waiting list
  */
  namespace pwemptiness {

    /*!
      \class emptiness_algorithm_t
      \brief Emptiness algorithm that uses a passed-waiting list. The algorithm
      explores a graph and checks if it has an reachable state that is accepting

      The class provides two exploration algorithms:
      - emptiness_check() checks emptiness of a graph starting from its
      initial node. Reports whether the system is empty or not. Relies on the
      other algorithm explore().
      - explore() checks whether an accepting node is reachable in a graph.
      Starts from the nodes that are in the passed-waiting list.

      emptiness_check():
        on_pre_emptiness_check()
        insert initial node in PW
        explore()
        on_post_emptiness_check()

      explore():
        while PW is not empty
	  get 1st waiting node
	  if it is accepting
	    on_accepting_node()
	    done
	  on_non_accepting_node()
	  if (on_pre_expand())
	    expand every successor edge
	    if it is enabled
	      on_expand_enabled_edge()
	      insert target node in PW
	    else
	      on_expand_disabled_edge()
	    on_post_expand()

      Events allow to easily parametrize and extend the algorithm:
      - on_pre_emptiness_check() allows to initialize the check
      - on_post_emptiness_check() allows to finalize the check
      - on_accepting_node() allows to take an action on the accepting node
      before the algorithm stops
      - on_non_accepting_node() allows to take an action on a node that is
      not accepting
      - on_pre_expand() allows to take action on a node before it is expanded
      and to tell the algorithm is the node should be expanded
      - on_expand_enabled_edge() is called for every expanded edge that is
      enabled
      - on_expand_disabled_edge() is called for every expanded edge that is
      disabled
      - on_post_expand() allows to take action on a node after it has been
      fully expanded

      \tparam NODE : type of nodes in the graph. We assume that NODE provides
      a method accepting which is the case if it derives from syntax::state_t
      \tparam EDGE : type of edges in the graph
    */
    template <class NODE, class EDGE>
    class emptiness_algorithm_t
      : public algorithms::emptiness_algorithm_t,
	public algorithms::graph_output_owner_t<NODE, EDGE> {
    protected:
      /*<! Graph */
      graph::graph_t<NODE, EDGE> & _graph;

      /*!< Passed-waiting list */
      sp_t< graph::pw_t<NODE> > _pw;

      /*!< Node counts */
      unsigned _nodes_count, _leaf_nodes_count;

      /*!
	\brief Emptiness check
	\return True if no accepting state is reachable, false otherwise
      */
      virtual bool emptiness_check() {
	bool accepting_reachable;

	on_pre_emptiness_check();

	// Insert initial node
	_pw->insert(_graph.initial());

	_nodes_count = 1;
	_leaf_nodes_count = 1;
	
	// Explore from passed-waiting list
	accepting_reachable = explore();

	on_post_emptiness_check();

	return (! accepting_reachable);
      }

      
      /*!
	\brief Explores the graph from the nodes in the waiting list
	\return True if an accepting node has been found, false otherwise.
	\post The algorithm stops at the first accepting node that it finds
       */
      virtual bool explore() {
	sp_t<NODE> current;
	std::list< std::pair< sp_t<EDGE>, sp_t<NODE> > > next;
	
	while ( ! _pw->wempty() ) {
	  // Gets current node
	  current = _pw->wnext();

	  this->_graph_output->node(current);
	  
	  // Done if current node is accepting
	  if ( current->accepting(this->accepting_labels()) ) {
	    on_accepting_node(current);
	    return true;
	  }
	
	  // Treat the current node
	  on_non_accepting_node(current);
	
	  // Expands the current node if needed
	  if ( ! on_pre_expand(current) )
	    continue;
	  
	  // Expand next nodes
	  next.clear();
	  _graph.next(current, next);
	  for (auto p : next) {
	    if (p.second.get() == nullptr) // unfireable edge
	      on_expand_disabled_edge(current, p.first);
	    else {
	      this->_graph_output->edge(current, p.second, p.first);

	      on_expand_enabled_edge(current, p.first);
	      _pw->insert(p.second);

	      ++ _nodes_count; // count new node and new leaf
	      ++ _leaf_nodes_count;
	    }
	  }

	  // Update leaf nodes count
	  if (! next.empty())
	    -- _leaf_nodes_count;

	  on_post_expand(current);
	}

	return false;
      }


      /*!
	\brief Event called before emptiness check starts
	\post Graph output has been started
       */
      virtual void on_pre_emptiness_check() {
	this->_graph_output->start();
      }

      
      /*!
	\brief Event called after emptiness check stops
	\post Statistics have been output and graph output has been stopped
       */
      virtual void on_post_emptiness_check() {
	// Size of the reachability tree
	std::cerr << "Number of nodes: " << _nodes_count;
	std::cerr << " (leaf nodes: " << _leaf_nodes_count;
	std::cerr << " non-leaf nodes: " << _nodes_count - _leaf_nodes_count;
	std::cerr << ")" << std::endl;

	// Size of the Passed-Waiting list
	std::cerr << "PW size: " << _pw->psize() << std::endl;

	this->_graph_output->end();
      }


      /*!
	\brief Event called when an accepting node is found
	\param node : accepting node
       */
      virtual void on_accepting_node(sp_t<NODE> node) {
      }


      /*!
	\brief Event called when a non-accepting node is found
	\param node : non-accepting node
       */
      virtual void on_non_accepting_node(sp_t<NODE> node) {
      }


      /*!
	\brief Event called before expanding a node. It should return true
	if the node must be expanded, and false if it should not be expanded
	\param node : node to expand
	\return True
       */
      virtual bool on_pre_expand(sp_t<NODE> node) {
	return true;
      }


      /*!
	\brief Event called when a disabled edge is found
	\param node : source node of the edge
	\param edge : disabled edge
       */
      virtual void on_expand_disabled_edge(sp_t<NODE> node, sp_t<EDGE> edge) {
      }


      /*!
	\brief Event called when an enabled edge is found
	\param node : source node of the edge
	\param edge : enabled edge
       */
      virtual void on_expand_enabled_edge(sp_t<NODE> node, sp_t<EDGE> edge) {
      }


      /*!
	\brief Event called after a node has been expanded
	\param node : expanded node
      */
      virtual void on_post_expand(sp_t<NODE> node) {
      }
    public:
      /*!
	\brief Constructor
	\param graph : graph to check for emptiness
	\param covered : covered predicate for the passed waiting list
	\param covering : covering predicate for the passed waiting list
	\param on_cover : cover event for the passed waiting list
	\param on_erase : erase event for the passed wainting list
	\param pw_flags : type of passed waiting list
	\param os : output stream
	\param output_flags : output flags
      */
      emptiness_algorithm_t(graph::graph_t<NODE, EDGE> & graph,
			    graph::nodes_cmp_t<NODE> const & covered,
			    graph::nodes_cmp_t<NODE> const & covering,
			    graph::pw_event_t<NODE> const & on_cover,
			    graph::pw_event_t<NODE> const & on_erase,
			    graph::pw_type_flags_t pw_flags,
			    std::ostream & os,
			    graph::output_type_flags_t output_flags)
	: algorithms::graph_output_owner_t<NODE, EDGE>(os, output_flags),
	  _graph(graph) {
	// Builds the passed waiting list
	graph::pw_factory_t & f_pw = graph::pw_factory_t::instance();
	_pw = f_pw.new_pw(covered, covering, on_cover, on_erase, pw_flags);
	assert( _pw.get() != nullptr );
      }

      /*!
	\brief Destructor
       */
      virtual ~emptiness_algorithm_t() = default;
    };

  } // end of namespace pwemptiness

} // end of namespace algorithms

#endif // __TCHECKER_ALGORITHMS_PW_EMPTINESS_HH__
