#ifndef __ALGORITHMS_CAV10BUCHIEMPTINESS_HH__
#define __ALGORITHMS_CAV10BUCHIEMPTINESS_HH__

#include <boost/bimap.hpp>
#include <boost/bimap/unordered_multiset_of.hpp>
#include <boost/bimap/unordered_set_of.hpp>
#include <queue>
#include <stack>
#include <stdint.h>
#include <vector>

#include "algorithms/algorithms.hh"
#include "algorithms/couvreurbuchiemptiness.hh"
#include "algorithms/emptiness.hh"
#include "base/clockset.hh"
#include "base/labelset.hh"
#include "graph/graph.hh"
#include "graph/reachset.hh"
#include "semantics/gzg.hh"
#include "syntax/system_builder.hh"

namespace algorithms {
  
  namespace cav10 {

    /**
       Emptiness check
       
       It handles the case of blocked clocks, i.e. clocks that are upper
       bounded infinitely often but reset only finitely often on a run. The
       semantics has to take care of zero checks (e.g. guessing zone graph)
    **/


    /*
     * Type of a blocked nodes store
     */

    template <class NODE> class blocked_nodes_store_t {
    protected:
      typedef pair<NODE *, clock_bitset_t> scc_ref_t;
      typedef boost::bimap<boost::bimaps::unordered_multiset_of<scc_ref_t>,
			   boost::bimaps::unordered_set_of<NODE *> > bm_t;
      typedef typename bm_t::left_iterator left_iterator;
      typedef typename bm_t::value_type value_type;
      bm_t _blocked_nodes;
    public:
      bool blocked(NODE * node) {
	return (_blocked_nodes.right.find(node) != _blocked_nodes.right.end());
      }

      bool empty(NODE * scc_root_node,
		 const clock_bitset_t & blocked_clocks) {
	return (_blocked_nodes.left.find(make_pair(scc_root_node,
						   blocked_clocks)) ==
		_blocked_nodes.left.end());
      }

      NODE * pop(NODE * scc_root_node,
		       const clock_bitset_t & blocked_clocks) {
	left_iterator it =
	  _blocked_nodes.left.find(make_pair(scc_root_node, blocked_clocks));
	if (it == _blocked_nodes.left.end())
	  throw "*** blocked_nodes_store_t::pop: empty store";
	_blocked_nodes.left.erase(it);
	return it->second;
      }

      void push(NODE * blocked_node,
		NODE * scc_root_node,
		const clock_bitset_t & blocked_clocks) {
	_blocked_nodes.insert(value_type(make_pair(scc_root_node,
						   blocked_clocks),
					 blocked_node));
      }
    };


    /* 
     * Type of todo stack entries
     */
    template <class NODE,class EDGE> class todo_entry_t :
      public algorithms::couvreurscc::todo_entry_t<NODE, EDGE> {
    public:
      todo_entry_t(NODE * node,
		   const vector<EDGE *> & vsuccs,
		   const clock_bitset_t & blocking_clocks,
		   NODE * upper_scc_root)
	: algorithms::couvreurscc::todo_entry_t<NODE, EDGE>(node, vsuccs),
	  _blocking_clocks(blocking_clocks),
	  _upper_scc_root(upper_scc_root) {
      }

      todo_entry_t(const todo_entry_t & todo_entry)
	: algorithms::couvreurscc::todo_entry_t<NODE, EDGE>(todo_entry),
	  _blocking_clocks(todo_entry._blocking_clocks),
	  _upper_scc_root(todo_entry._upper_scc_root) {
      }

      const clock_bitset_t & blocking_clocks(void) const {
	return _blocking_clocks;
      }

      NODE * upper_scc_root(void) const {
	return _upper_scc_root;
      }
    protected:
      const clock_bitset_t _blocking_clocks;
      NODE * _upper_scc_root;
    };



    /*
     * Type of roots stack entries
     */
    template <class NODE> class roots_entry_t :
      public algorithms::couvreurscc::roots_entry_t<NODE> {
    protected:
      bool _scc_clear_node;
      clock_bitset_t _scc_ub;
      clock_bitset_t _scc_reset;
      clock_bitset_t _ub;
      clock_bitset_t _reset;
    public:
      roots_entry_t(NODE * node,
		    const label_bitset_t & labels,
		    bool scc_clear_node,
		    const clock_bitset_t & scc_ub,
		    const clock_bitset_t & scc_reset,
		    const clock_bitset_t & ub,
		    const clock_bitset_t & reset)
	: algorithms::couvreurscc::roots_entry_t<NODE>(node, labels),
	  _scc_clear_node(scc_clear_node),
	  _scc_ub(scc_ub),
	  _scc_reset(scc_reset),
	  _ub(ub),
	  _reset(reset) {
      }

      roots_entry_t(const roots_entry_t & roots_entry) :
	algorithms::couvreurscc::roots_entry_t<NODE>(roots_entry),
	_scc_clear_node(roots_entry._scc_clear_node),
	_scc_ub(roots_entry._scc_ub),
	_scc_reset(roots_entry._scc_reset),
	_ub(roots_entry._ub),
	_reset(roots_entry._reset) {
      }

      bool scc_clear_node(void) const {
	return _scc_clear_node;
      }

      void scc_clear_node(bool scc_clear_node) {
	_scc_clear_node = scc_clear_node;
      }

      const clock_bitset_t & scc_ub(void) const {
	return _scc_ub;
      }

      clock_bitset_t & scc_ub(void) {
	return _scc_ub;
      }

      const clock_bitset_t & scc_reset(void) const {
	return _scc_reset;
      }

      clock_bitset_t & scc_reset(void) {
	return _scc_reset;
      }

      const clock_bitset_t & ub(void) const {
	return _ub;
      }

      clock_bitset_t & ub(void) {
	return _ub;
      }

      const clock_bitset_t & reset(void) const {
	return _reset;
      }

      clock_bitset_t & reset(void) {
	return _reset;
      }
    };
        
    /*
      Algorithm main class
     */
    class emptiness_algorithm_t : public algorithms::emptiness_algorithm_t
    <explore_scc_node_t<gzg::state_t>,
     guarded_edge_t< explore_scc_node_t<gzg::state_t> > >,
				  public algorithms::gzg_algorithm_t {
    protected:
      // Local types
      typedef explore_scc_node_t<gzg::state_t> node_t;
      typedef guarded_edge_t<node_t> edge_t;
      typedef graph_ts_t<gzg::gzg_t, node_t, edge_t> graph_t;
      typedef roots_entry_t<node_t> root_t;
      typedef todo_entry_t<node_t, edge_t> todo_t;

      // Graph and reachability set on the graph
      graph_t _graph;
      reachset_t<graph_t, node_t, edge_t> _reachset;

      // DFS number index
      uint32_t _count;
      
      // Stack of SCC roots
      stack<root_t> _roots;

      // Stack of active nodes
      stack<node_t *> _active;
      
      // Stack of nodes to explore
      stack<todo_t> _todo;
      
      // Store of blocked nodes
      blocked_nodes_store_t<node_t> _blocked_nodes;

      // Number of visited nodes (differs from _count due to re-exploration)
      uint32_t _visited_nodes_count;

      // Emptiness check functions
      bool emptiness_check(node_t * node);
      bool emptiness_check(void);

      // Initializing function
      void initialize(void);

      // Finalizing function
      void finalize(void);

      // Function called when a node is about to be explored
      void push_node(node_t * node,
		     const clock_bitset_t & ub,
		     const clock_bitset_t & reset,
		     const clock_bitset_t & blocking_clocks,
		     node_t * upper_scc_root);

      // Function called when some SCCs must be merged
      inline void merge_scc(node_t * node,
			    const clock_bitset_t & ub,
			    const clock_bitset_t & reset);

      // Function called when a maximal SCC has been entirely explored and
      // needs to be closed
      inline void close_scc(const clock_bitset_t & blocking);

      // Function called to determine if the top SCC in the roots stack
      // needs to be explored again (i.e. is accepting and blocked)
      inline bool explore_scc(void);
    public:
      emptiness_algorithm_t(syntax::system_builder_t & sb);
    };

  }

}

#endif
