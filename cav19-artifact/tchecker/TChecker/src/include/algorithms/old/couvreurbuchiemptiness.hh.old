#ifndef __ALGORITHMS_COUVREURBUCHIEMPTINESS_HH__
#define __ALGORITHMS_COUVREURBUCHIEMPTINESS_HH__

#include <queue>
#include <stack>
#include <stdint.h>
#include <vector>

#include "algorithms/algorithms.hh"
#include "algorithms/emptiness.hh"
#include "base/clockset.hh"
#include "base/labelset.hh"
#include "graph/graph.hh"
#include "graph/reachset.hh"
#include "semantics/zg.hh"
#include "syntax/system_builder.hh"

using namespace std;

namespace algorithms {
  
  namespace couvreurscc {
    
    /**
     * Emptiness check implementation of Couvreur's algorithm
     * 
     * This algorithm does not performs any check of non-Zenoness. Hence, it
     * should be applied on semantics that embeds non-Zenoness checks.
     **/  


    /*
     * Type of todo stack entries: nodes that need to be explored during
     * the search along with their successor edges
     */
    template <class NODE, class EDGE> class todo_entry_t {
    protected:
      NODE * _node;
      queue<EDGE*> _succs;
    public:
      todo_entry_t(NODE * node, const vector<EDGE*> & vsuccs) : _node(node) {
	for (typename vector<EDGE*>::const_iterator it = vsuccs.begin();
	     it != vsuccs.end(); ++it)
	  _succs.push(*it);
      }

      todo_entry_t(const todo_entry_t & todo) : _node(todo._node),
						_succs(todo._succs) {
      }
  
      bool has_succ(void) const {
	return (! _succs.empty());
      }
  
      EDGE * next_succ(void) {
	if (_succs.empty())
	  throw "*** todo_entry_t::next_succ(): no successor edge";

	EDGE * succ = _succs.front();
	_succs.pop();

	return succ;
      }
  
      NODE * node(void) {
	return _node;
      }
    };



    /*
     * Type of roots stack entries: the roots of maximal SCCs (as of the
     * current search) along with the set of accepting labels in the SCC
     */
    template <class NODE> class roots_entry_t {
    protected:
      NODE * _node;
      label_bitset_t _scc_labels;
    public:
      roots_entry_t(NODE * node,
		    const label_bitset_t & scc_labels)
	: _scc_labels(scc_labels) {
	_node = node;
      }

      roots_entry_t(NODE * node,
		    const labels_t & scc_labels) : _scc_labels(scc_labels) {
	_node = node;
      }
      
      roots_entry_t(const roots_entry_t & root)
      : _scc_labels(root._scc_labels) {
	_node = root._node;
      }
      
      NODE * node(void) const {
	return _node;
      }

      void node(NODE * node) {
	_node = node;
      }
      
      const label_bitset_t & scc_labels(void) const {
	return _scc_labels;
      }

      label_bitset_t & scc_labels(void) {
	return _scc_labels;
      }
    };

        
    /*
     * Algorithm main class
     */
    class emptiness_algorithm_t : public algorithms::emptiness_algorithm_t
    <scc_node_t<zg::state_t>, basic_edge_t<scc_node_t<zg::state_t> > >,
				  public zg_snz_algorithm_t {
    protected:
      // Local types
      typedef scc_node_t<zg::state_t> node_t;
      typedef basic_edge_t<node_t> edge_t;
      typedef graph_ts_t<zg::zg_t, node_t, edge_t> graph_t; // ZG built over SNZ
      typedef roots_entry_t<node_t> root_t;
      typedef todo_entry_t<node_t, edge_t> todo_t;

      // Graph and reachability set on the graph
      graph_t _graph;
      reachset_t<graph_t, node_t, edge_t> _reachset;

      // DFS number index (counts the number of nodes)
      uint32_t _count;
      
      // Stack of SCC roots
      stack<root_t> _roots;

      // Stack of active nodes
      stack<node_t*> _active;

      // Stack of nodes to explore
      stack<todo_t> _todo;

      // Emptiness check functions (Couvreur's algorithm)
      bool emptiness_check(node_t * node);
      bool emptiness_check(void);

      // Initializing function
      void initialize(void);

      // Finalizing function
      void finalize(void);

      // Function called when a node is about to be explored
      void push_node(node_t * node);

      // Function called when some SCCs must be merged
      void merge_scc(node_t * node);

      // Function called when a maximal SCC has been entirely explored and
      // needs to be closed
      void close_scc(void);
    public:
      emptiness_algorithm_t(syntax::system_builder_t & sb);
    };

  }

}

#endif
