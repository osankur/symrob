#ifndef __TCHECKER_OPERATIONAL_HH__
#define __TCHECKER_OPERATIONAL_HH__

#include <dbm/constraints.h>
#include <dbm/mingraph.h>

#include "base/cast.hh"
#include "base/global.hh"
#include "semantics/operational_dbm.hh"
#include "symbolic/dbm_utils.hh"
#include "symbolic/zone.hh"
#include "syntax/model.hh"
#include "syntax/ta.hh"

/*!
  \file operational.hh
  \brief Operational semantics for timed automata (for zones represented by
  abstract type zone_t)

  Operational semantics define how zones are computed with respect to a given
  timed automaton. An operational semantics yields:
  - initial zone computation according to the invariant and flags in the initial
  state in the automaton
  - next zone computation from a given zone and a given transition of the
  automaton. It takes into account the invariants and flags in the source state
  and the target state, as well as the guard and resets of the transition.
  
  Operational semantics are intended to serve as generators of the reachable
  zones in a timed automaton. It is usually expected that all the zones are
  generated by the same operational semantics.
*/

namespace semantics {

  /*!
    \class operational_zone_t
    \brief Interface for operational semantics using abstract representation
    symbolic::zone_t for zones
    \tparam DATA : type of extra data needed by semantics
   */
  template <class DATA>
  class operational_zone_t {
  public:
    /*!
      \brief Destructor
    */
    virtual ~operational_zone_t() = default;

    /*!
      \brief Initial zone computation
      \param s : initial state
      \param d : extra data
      \return The initial zone of the timed automaton, taking into account
      flags and invariant in state s, and extra data d.
      \note The caller should handle the memory allocated for the new zone.
    */
    virtual symbolic::zone_t * initial(syntax::state_t const & s,
                                       DATA d) = 0;

    /*!
      \brief Next zone computation
      \param src : source state
      \param d : extra data
      \param z : source zone
      \param t : transition
      \param tgt : target state
      \return The zone obtained by applying transition t and time elapse
      taking into account flags and invariants in states src and tgt, and extra
      data d (in a way to be defined by a low-level operational semantics).
      \note The returned zone is empty if z is empty
      \note The caller should handle the memory allocated for the new zone.
    */
    virtual symbolic::zone_t * next(syntax::state_t const & src,
                                    DATA d,
                                    symbolic::zone_t const & z,
                                    syntax::vedge_t const & vedge,
                                    syntax::state_t const & tgt) = 0;

    virtual void pre(syntax::state_t const & src,
                     DATA d,
                     raw_t * z,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt, cindex_t dim) = 0;
    /*!
      \brief Outputs stats
      \param level : stats level
      \post Does not output nothing
     */
    virtual void stats(unsigned level) const = 0;
  };



  /*!
    \class operational_zone_dbm_t
    \brief Operational semantics for zones represented using
    symbolic::zone_dbm_t.
    \tparam OPERATIONAL_DBM : low-level operational semantics on DBMs
    (see operational_dbm.hh)
  */
  template <class OPERATIONAL_DBM>
  class operational_zone_dbm_t
      : public operational_zone_t<typename OPERATIONAL_DBM::data_t> {
  public:
    /*!
      \brief Constructor
      \param model : model for which operational semantics is built
    */
    operational_zone_dbm_t(syntax::model_t & model) : _operational(model) {
    }

    /*!
      \brief Destructor
    */
    virtual ~operational_zone_dbm_t() = default;
    
    /*!
      \brief see operational_zone_t::initial
      \post The initial zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_dbm_t
    */
    virtual symbolic::zone_t * initial(syntax::state_t const & s,
                                       typename OPERATIONAL_DBM::data_t d) {
      symbolic::zone_dbm_t * z_dbm = new symbolic::zone_dbm_t();
      assert( z_dbm != nullptr );

      z_dbm->apply
          ([&] (raw_t * dbm, cindex_t dim) {
        _operational.initial(s, dbm, dim, d);
      });

      return z_dbm;
    }

    /*!
      \brief see operational_zone_t::next
      \pre z points to an instance of symbolic::zone_dbm_t (checked if flag
      SAFE_CAST is set at compilation time).
      \post The next zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_dbm_t
    */
    virtual symbolic::zone_t * next(syntax::state_t const & src,
                                    typename OPERATIONAL_DBM::data_t d,
                                    symbolic::zone_t const & z,
                                    syntax::vedge_t const & vedge,
                                    syntax::state_t const & tgt) {
      symbolic::zone_dbm_t const & z_dbm =
          CAST(symbolic::zone_dbm_t const &, z);

      symbolic::zone_dbm_t * z_dbm_next = new symbolic::zone_dbm_t(z_dbm);
      assert( z_dbm_next != nullptr );

      if ( ! z_dbm_next->empty() )
        z_dbm_next->apply
            ([&] (raw_t * dbm, cindex_t dim) {
          _operational.next(src, dbm, dim, vedge, tgt, d);
        });

      return z_dbm_next;
    }
    virtual void pre(syntax::state_t const & src,
                     typename OPERATIONAL_DBM::data_t d,
                     raw_t * z,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt, cindex_t dim) {
      _operational.pre(src, z, dim, vedge, tgt, d);
    }
    /*!
      \brief Outputs stats (see operational_zone_t::stats)
      \post Does not output nothing
     */
    virtual void stats(unsigned level) const {
    }
  protected:
    OPERATIONAL_DBM _operational; /*!< Underlying operational semantics */
  };




  /*!
    \class operational_zone_shdbm_t
    \brief Operational semantics for zones represented using
    symbolic::zone_shdbm_t.
    \tparam OPERATIONAL_DBM : low-level operational semantics on DBMs
    (see operational_dbm.hh)
  */
  template <class OPERATIONAL_DBM>
  class operational_zone_shdbm_t
      : public operational_zone_t<typename OPERATIONAL_DBM::data_t> {
  public:
    /*!
      \brief Constructor
      \param model : model for which operational semantics is built
    */
    operational_zone_shdbm_t(syntax::model_t & model)
      : _operational(model),
        _cache(global_t::instance().cache_shared_zone_size) {
    }

    /*!
      \brief Destructor
    */
    virtual ~operational_zone_shdbm_t() {
      _cache.clear_and_dispose([] (symbolic::shared_zone_t * z) { delete z; });
    }
    
    /*!
      \brief see operational_zone_t::initial
      \post The initial zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_shdbm_t and is
      shared
    */
    virtual symbolic::zone_t * initial(syntax::state_t const & s,
                                       typename OPERATIONAL_DBM::data_t d) {
      symbolic::zone_shdbm_t * z_shdbm = new symbolic::zone_shdbm_t();
      assert( z_shdbm != nullptr );

      z_shdbm->apply
          ([&] (raw_t * dbm, cindex_t dim) {
        _operational.initial(s, dbm, dim, d);
      });

      z_shdbm->share(_cache);

      return z_shdbm;
    }

    /*!
      \brief see operational_zone_t::next
      \pre z points to an instance of symbolic::zone_shdbm_t (checked if flag
      SAFE_CAST is set at compilation time).
      \post The next zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_shdbm_t and is
      shared
    */
    virtual symbolic::zone_t * next(syntax::state_t const & src,
                                    typename OPERATIONAL_DBM::data_t d,
                                    symbolic::zone_t const & z,
                                    syntax::vedge_t const & vedge,
                                    syntax::state_t const & tgt) {
      symbolic::zone_shdbm_t const & z_shdbm =
          CAST(symbolic::zone_shdbm_t const &, z);

      symbolic::zone_shdbm_t * z_shdbm_next =
          new symbolic::zone_shdbm_t(z_shdbm);
      assert( z_shdbm_next != nullptr );

      if ( ! z_shdbm_next->empty() )
        z_shdbm_next->apply
            ([&] (raw_t * dbm, cindex_t dim) {
          _operational.next(src, dbm, dim, vedge, tgt, d);
        });

      z_shdbm_next->share(_cache);

      return z_shdbm_next;
    }


    virtual void pre(syntax::state_t const & src,
                     typename OPERATIONAL_DBM::data_t d,
                     raw_t * z,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt, cindex_t dim) {
      _operational.pre(src, z, dim, vedge, tgt, d);
    }
    /*!
    /*!
      \brief Outputs stats (see operational_zone_t::stats)
      \post The memory footprint of the cache of shared zones has been output
      to std::cout (level >= 2)
     */
    virtual void stats(unsigned level) const {
      // Level 2
      if (level < 2)
        return;

      std::size_t shared_zones_size = _cache.memsize();
      for (symbolic::shared_zone_t const & z : _cache)
        shared_zones_size += z.memsize();

      std::cout << stats::ZONES_SHARED_CACHE_SIZE << _cache.size() << std::endl
                << stats::ZONES_SHARED_CACHE_MEM << shared_zones_size
                << std::endl;
    }
  protected:
    OPERATIONAL_DBM _operational;         /*!< Operational semantics */
    symbolic::shared_zone_cache_t _cache; /*!< Cache of shared ones */
  };




  /*!
    \class operational_zone_mg_t
    \brief Operational semantics for zones represented using
    symbolic::zone_mg_t
    \tparam OPERATIONAL_DBM : low-level operational semantics on DBMs
    (see operational_dbm.hh)
  */
  template <class OPERATIONAL_DBM>
  class operational_zone_mg_t
      : public operational_zone_t<typename OPERATIONAL_DBM::data_t> {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_zone_mg_t(syntax::model_t & model) : _operational(model) {
      _dim = global_t::instance().clock_index().size();
      _dbm = new raw_t[_dim * _dim];
      assert( _dbm != nullptr );
    }

    /*!
      \brief Destructor
    */
    ~operational_zone_mg_t() {
      delete[] _dbm;
    }

    /*!
      \brief see operational_zone_t::initial
      \post The initial zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_mg_t
    */
    virtual symbolic::zone_t * initial(syntax::state_t const & s,
                                       typename OPERATIONAL_DBM::data_t d) {
      symbolic::zone_mg_t * z_mg;
      
      _operational.initial(s, _dbm, _dim, d);
      z_mg = new symbolic::zone_mg_t(_dbm, _dim);
      assert( z_mg != nullptr );
      
      return z_mg;
    }

    /*!
      \brief see operational_zone_sp_t::next
      \pre z points to an instance of symbolic::zone_mg_t (checked if flag
      SAFE_CAST is set at compilation time)
      \post The next zone has been computed according to OPERATIONAL_DBM
      \note The returned zone is an instance of symbolic::zone_mg_t
    */
    virtual symbolic::zone_t * next(syntax::state_t const & src,
                                    typename OPERATIONAL_DBM::data_t d,
                                    symbolic::zone_t const & z,
                                    syntax::vedge_t const & vedge,
                                    syntax::state_t const & tgt) {
      // IMPLEMENTATION NOTE: don't use apply() to avoid allocation/deallocation
      // of DBM
      if ( z.empty() )
        symbolic::dbm_empty(_dbm, _dim);
      else {
          symbolic::zone_mg_t const & z_mg = CAST(symbolic::zone_mg_t const &, z);
          dbm_readFromMinDBM(_dbm, z_mg.get());
          _operational.next(src, _dbm, _dim, vedge, tgt, d);
        }
      symbolic::zone_mg_t * z_mg_next = new symbolic::zone_mg_t(_dbm, _dim);
      assert(z_mg_next != nullptr);

      return z_mg_next;
    }
    virtual void pre(syntax::state_t const & src,
                     typename OPERATIONAL_DBM::data_t d,
                     raw_t * z,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt, cindex_t dim) {
      _operational.pre(src, z, dim, vedge, tgt, d);
    }
    /*!

    /*!
      \brief Outputs stats (see operational_zone_t::stats)
      \post Does not output nothing
     */
    virtual void stats(unsigned level) const {
    }
  protected:
    OPERATIONAL_DBM _operational; /*!< Underlying operational semantics */
    raw_t * _dbm;                 /*!< For conversion from/to mingraph */
    cindex_t _dim;                /*!< Dimension of _dbm */
  };

} // end of namespace semantics


#endif // __TCHECKER_OPERATIONAL_HH__
