#ifndef __TCHECKER_OPERATIONAL_DBM_HH__
#define __TCHECKER_OPERATIONAL_DBM_HH__

#include "base/clockindex.hh"
#include "base/global.hh"
#include "semantics/operations_dbm.hh"
#include "symbolic/dbm_utils.hh"
#include "syntax/model.hh"
#include "syntax/ta.hh"

/*!
  \file operational_dbm.hh
  \brief Operational semantics for timed automata (for zones represented by
  DBMs, i.e. raw_t square matrices)

  Operational semantics define how zones are computed with respect to a given
  timed automaton and to basic operations. An operational semantics yields:
  - initial zone computation according to the invariant and flags in the initial
  state in the automaton
  - next zone computation from a given zone and a given transition of the
  automaton. It takes into account the invariants and flags in the source state
  and the target state, as well as the guard and resets of the transition.
  
  Operational semantics are intended to serve as generators of the reachable
  zones in a timed automaton. It is usually expected that all the zones are
  generated by the same operational semantics as distinct semantics may generate
  distinct reachable zones.
*/

namespace semantics {

  // Basic operational semantics

  /*!
    \class operational_el_dbm_t
    \brief Elapsed-last operational semantics
    
    The class defines how initial zones and next zones are computed according
    to given basic operations. In the elapsed-last semantics, transitions are
    applied first, and time is elapsed last, hence the name.

    \tparam OPERATIONS : basic operations used to define the operational
    semantics. Is expected to derive from operations_dbm_t
   */
  template <class OPERATIONS>
  class operational_el_dbm_t {
  public:
    /*!
      \brief Type of data
    */
    typedef typename OPERATIONS::data_t data_t;

    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_el_dbm_t(syntax::model_t & model) : _operations(model) {
    }

    /*!
      \brief Destructor
    */
    virtual ~operational_el_dbm_t() = default;

    /*!
      \brief Initial zone computation

      Corresponds to the following sequence of operations:
      - on_zero_valuation(...)
      - on_time_elapse(...)
      - on_inv(...)

      \param s : initial state
      \param z : zone (DBM)
      \param dim : dimension of z
      \param d : extra data
      \return True if it yields a non-empty zone, false otherwise
      \pre z is an allocated raw_t[dim * dim]. dim >= 1.
      \post z is the initial zone of _model in state s, obtained by taking the
      valuation where all the clocks have value 0, then by letting time elapse
      (if allowed in s), and eventually, by applying the invariant in state s.
      Each one of these steps is performed using OPERATIONS. z is tight unless
      z is empty (then dbm_isEmpty(z, dim) returns TRUE)
    */
    virtual bool initial(syntax::state_t const & s, raw_t * z, cindex_t dim,
                         typename OPERATIONS::data_t d) {
      if ( _operations.on_zero_valuation(z, dim, d) &&
           _operations.on_time_elapse(s, z, dim, d) &&
           _operations.on_inv(s, z, dim, d) )
        return true;

      symbolic::dbm_empty(z, dim);
      return false;
    }

    /*!
      \brief Next zone computation

      Corresponds to the following sequence of operations:
      - on_guard(...)
      - on_reset(...)
      - on_time_elapse(...)
      - on_inv(...)
      We assume that z is contained in the invariant in state src. This is
      guaranteed if z has been generated by this class.

      \param src : source state
      \param z : zone (DBM)
      \param dim : dimension of z
      \param vedge : tuple of synchronized edges
      \param tgt : target state
      \param d : extra data
      \return True if it yields an non-empty zone, false otherwise
      \pre z is an allocated raw_t[dim * dim]. It represents the zone in
      state src. z is contained in the invariant of state src (which is the
      case if z has been generated by this class). z is tight. dim >= 1.
      \post z has been applied transition vedge, then time elapse (if enabled
      in state tgt). Each one of these steps is performed using OPERATIONS. z
      is tight unless z is empty (then dbm_isEmpty(z, dim) returns TRUE)
    */
    virtual bool next(syntax::state_t const & src, raw_t * z, cindex_t dim,
                      syntax::vedge_t const & vedge,
                      syntax::state_t const & tgt,
                      typename OPERATIONS::data_t d) {
      if ( _operations.on_guard(vedge, z, dim, d) &&
           _operations.on_reset(vedge, z, dim, d) &&
           _operations.on_time_elapse(tgt, z, dim, d) &&
           _operations.on_inv(tgt, z, dim, d) )
        return true;

      symbolic::dbm_empty(z, dim);
      return false;
    }

    virtual bool pre(syntax::state_t const & src, raw_t * z, cindex_t dim,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt,
                     typename OPERATIONS::data_t d) {

      if (_operations.on_inv(tgt, z, dim, d) &&
          _operations.on_time_down(tgt, z, dim, d) &&
          _operations.on_backreset(vedge, z, dim, d) &&
          _operations.on_guard(vedge, z, dim, d) ) return true;
      symbolic::dbm_empty(z, dim);
      return false;

    }

  protected:
    OPERATIONS _operations; /*!< Underlying operations */
  };



  /*!
    \class operational_el_lazyinv_dbm_t
    \brief Elapsed-last lazy-invariant operational semantics
    
    The class defines how initial zones and next zones are computed according
    to given basic operations. The lazy-invariant semantics is a variation
    of the elapsed-last semantics (see operational_el_dbm_t) that consists in
    applying the state invariants in the guards of the outgoing transitions.
    Correctness is ensured by checking that reachable zones have a non-empty
    intersection with the state invariants.

    \tparam OPERATIONS : basic operations used to define the operational
    semantics. Is expected to derive from operations_dbm_t
   */
  template <class OPERATIONS>
  class operational_el_lazyinv_dbm_t {
  public:
    /*!
      \brief Type of data
    */
    typedef typename OPERATIONS::data_t data_t;

    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_el_lazyinv_dbm_t(syntax::model_t & model) : _operations(model) {
      cindex_t dim = global_t::instance().clock_index().size();
      _dbm = new raw_t[dim * dim];
      assert( _dbm != nullptr );
    }

    /*!
      \brief Destructor
    */
    virtual ~operational_el_lazyinv_dbm_t() {
      delete[] _dbm;
    }

    /*!
      \brief Initial zone computation

      Corresponds to the following sequence of operations:
      - on_zero_valuation(...)
      - on_time_elapse(...)
      - checking that the resulting zone has a non-empty intersection with the
      invariant in state s

      \param s : initial state
      \param z : zone (DBM)
      \param dim : dimension of z
      \param d : extra data
      \return True if it yields a non-empty zone, false otherwise
      \pre z is an allocated raw_t[dim * dim]. dim >= 1.
      \post z is the initial zone of _model in state s obtained by taking the
      valuation where all the clocks have value 0, then letting time elapse
      (if allowed in state s). The set of reachable valuations in state s
      corresponds to z interesected with the invariant in s. Each one of these
      steps is performed using OPERATIONS. z is tight unless z is empty (then
      dbm_isEmpty(z, dim) returns TRUE)
    */
    virtual bool initial(syntax::state_t const & s, raw_t * z, cindex_t dim,
                         typename OPERATIONS::data_t d) {
      if ( _operations.on_zero_valuation(z, dim, d) &&
           _operations.on_time_elapse(s, z, dim, d) &&
           non_empty_intersection_invariant(s, z, dim) )
        return true;

      symbolic::dbm_empty(z, dim);
      return false;
    }

    /*!
      \brief Next zone computation

      Corresponds to the following sequence of operations:
      - on_inv(...) with invariant in state src
      - on_guard(...)
      - on_reset(...)
      - on_time_elapse(...)
      - checking that the resulting zone has a non-empty intersection with the
      invariant in state tgt

      \param src : source state
      \param z : zone (DBM)
      \param dim : dimension of z
      \param vedge : tuple of synchronized edges
      \param tgt : target state
      \param d : extra data
      \return True if it yields an non-empty zone, false otherwise
      \pre z is an allocated raw_t[dim * dim]. It represents the zone in
      state src. z is tight. dim >= 1.
      \post z has been applied transition vedge, then time elapse (if enabled).
      The set of reachable valuations in state tgt corresponds to z interesected
      with the invariant in tgt. Each one of these steps is performed using
      OPERATIONS. z is tight unless z is empty (then dbm_isEmpty(z, dim) returns
      TRUE)
    */
    virtual bool next(syntax::state_t const & src, raw_t * z, cindex_t dim,
                      syntax::vedge_t const & vedge,
                      syntax::state_t const & tgt,
                      typename OPERATIONS::data_t d) {
      if ( _operations.on_inv(src, z, dim, d) &&
           _operations.on_guard(vedge, z, dim, d) &&
           _operations.on_reset(vedge, z, dim, d) &&
           _operations.on_time_elapse(tgt, z, dim, d) &&
           non_empty_intersection_invariant(tgt, z, dim) )
        return true;

      symbolic::dbm_empty(z, dim);
      return false;
    }
    
    virtual bool pre(syntax::state_t const & src, raw_t * z, cindex_t dim,
                     syntax::vedge_t const & vedge,
                     syntax::state_t const & tgt,
                     typename OPERATIONS::data_t d) {

      if (non_empty_intersection_invariant(tgt, z, dim)  &&
          _operations.on_time_down(tgt, z, dim, d) &&
          _operations.on_backreset(vedge, z, dim, d) &&
          _operations.on_guard(vedge, z, dim, d) &&
          _operations.on_inv(src, z, dim, d)) return true;
      symbolic::dbm_empty(z, dim);
      return false;

    }
  protected:
    /*!
      \brief Checks non-empty intersection of a zone with a state invariant
      \param s : the state
      \param z : the zone (DBM)
      \param dim : dimension of z
      \return True if z has a empty intersection with the invariant in s,
      false otherwise
     */
    bool non_empty_intersection_invariant(syntax::state_t const & s, raw_t * z,
                                          cindex_t dim) {
      dbm_copy(_dbm, z, dim);

      syntax::vloc_t const * vloc = s.vloc();

      for (syntax::loc_t const * loc : *vloc)
        if ( ! symbolic::dbm_constrain(_dbm, dim, loc->inv()) )
          return false;
      
      return true;
    }

    OPERATIONS _operations; /*!< Underlying operations */
    raw_t * _dbm;           /*!< Used to check consistency of the invariants */
  };



  // Operational semantics with extrapolation

  /*!
    \class operational_extra_dbm_t
    \brief Operational semantics on DBMs that extrapolates zones
    \tparam OPERATIONAL_DBM : an operational semantics on DBMs. It is
    expected to derive from semantics::operational_dbm_t
  */
  template <class OPERATIONAL_DBM>
  class operational_extra_dbm_t : public OPERATIONAL_DBM {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_extra_dbm_t(syntax::model_t & model) : OPERATIONAL_DBM(model) {
    }
    
    /*!
      \brief Initial zone computation (see semantics::operational_dbm_t)
      \return True if it yields a non-empty zone, false otherwise
      \post z is the extrapolation of the initial zone of _model in state s
      as defined by OPERATIONAL_DBM. z may not have been extrapolated if
      OPERATIONAL_DBM yields an empty initial zone. z is tight unless z is
      empty (then dbm_isEmpty(z, dim) returns TRUE)
    */
    virtual bool initial(syntax::state_t const & s, raw_t * z, cindex_t dim,
                         typename OPERATIONAL_DBM::data_t d) {
      if ( ! this->OPERATIONAL_DBM::initial(s, z, dim, d) )
        return false;

      return on_extrapolate(s, z, dim, d);
    }

    /*!
      \brief Next zone computation (see semantics::operational_dbm_t)
      \return True if it yields an non-empty zone, false otherwise
      \post z is the extrapolation of the next zone of z along t as defined by
      OPERATIONAL_DBM. z may not have been extrapolated if OPERATIONAL_DBM
      yields an empty next zone. z is tight unless z is empty (then
      dbm_isEmpty(z, dim) returns TRUE)
    */
    virtual bool next(syntax::state_t const & src, raw_t * z, cindex_t dim,
                      syntax::vedge_t const & vedge,
                      syntax::state_t const & tgt,
                      typename OPERATIONAL_DBM::data_t d) {
      if ( ! this->OPERATIONAL_DBM::next(src, z, dim, vedge, tgt, d) )
        return false;

      return on_extrapolate(tgt, z, dim, d);
    }

    /*!
      \brief Destructor
    */
    virtual ~operational_extra_dbm_t()  = default;
  protected:
    /*!
      \brief Extrapolation function
      \param s : state
      \param z : zone to extrapolate (DBM)
      \param dim : dimension of z
      \param d : extra data
      \pre z is an allocated raw_t[dim * dim]. z is tight (checked by
      assertion). dim >= 1.
      \post z has been extrapolated. z is tight.
    */
    virtual bool on_extrapolate(syntax::state_t const & s,
                                raw_t * z, cindex_t dim,
                                typename OPERATIONAL_DBM::data_t d) = 0;
  };

  
  /*!
    \class operational_exlug_dbm_t
    \brief Operational semantics on DBMs that extrapolates zones using
    extrapolation ExtraLU+ and global LU bounds
    \tparam OPERATIONAL_DBM : an operational semantics on DBMs. It is
    expected to derive from semantics::operational_dbm_t
  */
  template <class OPERATIONAL_DBM>
  class operational_exlug_dbm_t
      : public operational_extra_dbm_t<OPERATIONAL_DBM> {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_exlug_dbm_t(syntax::model_t & model)
      : operational_extra_dbm_t<OPERATIONAL_DBM>(model) {
      model.system_bounds().global_LU(_lu);
    }

    /*!
      \brief Destructor
    */
    ~operational_exlug_dbm_t() = default;
  protected:
    /*!
      \brief see operational_extra_dbm_t::on_extrapolate
      \return True
      \post d has not been modified
    */
    bool on_extrapolate(syntax::state_t const & s,
                        raw_t * z, cindex_t dim,
                        typename OPERATIONAL_DBM::data_t d) {
      assert( z != nullptr );
      assert( dbm_isClosed(z, dim) == TRUE );
      dbm_diagonalExtrapolateLUBounds(z, dim, _lu.L(), _lu.U());
      return true;
    }

    syntax::LU_bounds_t _lu; /*!< Global LU bounds */
  };

  
  /*!
    \class operational_exlul_dbm_t
    \brief Operational semantics on DBMs that extrapolates zones using
    extrapolation ExtraLU+ and local LU bounds
    \tparam OPERATIONAL_DBM : an operational semantics on DBMs. It is
    expected to derive from semantics::operational_dbm_t
  */
  template <class OPERATIONAL_DBM>
  class operational_exlul_dbm_t
      : public operational_extra_dbm_t<OPERATIONAL_DBM> {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_exlul_dbm_t(syntax::model_t & model)
      : operational_extra_dbm_t<OPERATIONAL_DBM>(model),
        _system_bounds(model.system_bounds()) {
    }

    /*!
      \brief Destructor
    */
    ~operational_exlul_dbm_t() = default;
  protected:
    /*!
      \brief see operational_extra_dbm_t::on_extrapolate
      \return True
      \post d has not been modified
    */
    bool on_extrapolate(syntax::state_t const & s,
                        raw_t * z, cindex_t dim,
                        typename OPERATIONAL_DBM::data_t d) {
      assert( z != nullptr );
      assert( dbm_isClosed(z, dim) == TRUE );
      _system_bounds.local_LU(* s.vloc(), _lu);
      dbm_diagonalExtrapolateLUBounds(z, dim, _lu.L(), _lu.U());
      return true;
    }

    syntax::system_bounds_t const & _system_bounds; /*!< Provides bounds */
    syntax::LU_bounds_t _lu;                        /*!< Local LU bounds */
  };


  /*!
    \class operational_exmg_dbm_t
    \brief Operational semantics on DBMs that extrapolates zones using
    extrapolation ExtraM+ and global M bounds
    \tparam OPERATIONAL_DBM : an operational semantics on DBMs. It is
    expected to derive from semantics::operational_dbm_t
  */
  template <class OPERATIONAL_DBM>
  class operational_exmg_dbm_t
      : public operational_extra_dbm_t<OPERATIONAL_DBM> {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_exmg_dbm_t(syntax::model_t & model)
      : operational_extra_dbm_t<OPERATIONAL_DBM>(model) {
      model.system_bounds().global_M(_m);
    }

    /*!
      \brief Destructor
    */
    ~operational_exmg_dbm_t() = default;
  protected:
    /*!
      \brief see operational_extra_dbm_t::on_extrapolate
      \return True
      \post d has not been modified
    */
    bool on_extrapolate(syntax::state_t const & s,
                        raw_t * z, cindex_t dim,
                        typename OPERATIONAL_DBM::data_t d) {
      assert( z != nullptr );
      assert( dbm_isClosed(z, dim) == TRUE );
      dbm_diagonalExtrapolateMaxBounds(z, dim, _m.M());
      return true;
    }

    syntax::M_bounds_t _m; /*!< Global M bounds */
  };

  
  /*!
    \class operational_exml_dbm_t
    \brief Operational semantics on DBMs that extrapolates zones using
    extrapolation ExtraM+ and local M bounds
    \tparam OPERATIONAL_DBM : an operational semantics on DBMs. It is
    expected to derive from semantics::operational_dbm_t
  */
  template <class OPERATIONAL_DBM>
  class operational_exml_dbm_t
      : public operational_extra_dbm_t<OPERATIONAL_DBM> {
  public:
    /*!
      \brief Constructor
      \param model : model (i.e. timed automaton) for which operational
      semantics is built
    */
    operational_exml_dbm_t(syntax::model_t & model)
      : operational_extra_dbm_t<OPERATIONAL_DBM>(model),
        _system_bounds(model.system_bounds()) {
    }

    /*!
      \brief Destructor
    */
    ~operational_exml_dbm_t() = default;
  protected:
    /*!
      \brief see operational_extra_dbm_t::on_extrapolate
      \return True
      \post d has not been modified
    */
    bool on_extrapolate(syntax::state_t const & s,
                        raw_t * z, cindex_t dim,
                        typename OPERATIONAL_DBM::data_t d) {
      assert( z != nullptr );
      assert( dbm_isClosed(z, dim) == TRUE );
      _system_bounds.local_M(* s.vloc(), _m);
      dbm_diagonalExtrapolateMaxBounds(z, dim, _m.M());
      return true;
    }

    syntax::system_bounds_t const & _system_bounds; /*!< Provides bounds */
    syntax::M_bounds_t _m;                          /*!< Local M bounds */
  };


} // end of namespace semantics

#endif // __TCHECKER_OPERATIONAL_DBM_HH__
